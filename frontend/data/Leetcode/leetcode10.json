{
  "ID": "leetcode10",
  "coding_practice": [
    {
      "title": "Regular Expression Matching",
      "description": "Given an input string s and a pattern p, implement regular expression matching with support for '.' and '*' where:\n\n'.' Matches any single character.\n'*' Matches zero or more of the preceding element.\nThe matching should cover the entire input string (not partial).",
      "examples": [
        {
          "input": "s = \"aa\", p = \"a\"",
          "output": "false",
          "explanation": "\"a\" does not match the entire string \"aa\"."
        },
        {
          "input": "s = \"aa\", p = \"a*\"",
          "output": "true",
          "explanation": "'*' means zero or more of the preceding element, 'a'. Therefore, by repeating 'a' once, it becomes \"aa\"."
        },
        {
          "input": "s = \"ab\", p = \".*\"",
          "output": "true",
          "explanation": "\".*\" means \"zero or more (*) of any character (.)\"."
        }
      ],
      "constraints": "1 <= s.length <= 20\n1 <= p.length <= 20\ns contains only lowercase English letters.\np contains only lowercase English letters, '.', and '*'.\nIt is guaranteed for each appearance of the character '*', there will be a previous valid character to match.",
      "solution": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        m, n = len(s), len(p)\n        dp = [[False] * (n + 1) for _ in range(m + 1)]\n        dp[0][0] = True\n\n        for j in range(2, n + 1):\n            if p[j - 1] == '*':\n                dp[0][j] = dp[0][j - 2]\n\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if p[j - 1] == s[i - 1] or p[j - 1] == '.':\n                    dp[i][j] = dp[i - 1][j - 1]\n                elif p[j - 1] == '*':\n                    dp[i][j] = dp[i][j - 2]\n                    if p[j - 2] == s[i - 1] or p[j - 2] == '.':\n                        dp[i][j] = dp[i][j] or dp[i - 1][j]\n        return dp[m][n]",
      "explanation": "1. 使用二維動態規劃 dp[i][j] 表示 s[0..i-1] 與 p[0..j-1] 是否匹配。\n2. 處理字元匹配或 '.' 匹配任意字元。\n3. 處理 '*' 可匹配零個或多個前一個字元，更新 dp 狀態。\n4. 初始化空字串與模式的匹配狀態。\n5. 最終返回 dp[m][n] 作為匹配結果。",
      "tag": "520",
      "difficult": "hard"
    }
  ]
}
