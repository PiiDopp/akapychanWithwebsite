{
  "ID": "leetcode146",
  "coding_practice": [
    {
      "title": "LRU Cache",
      "description": "Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.\n\nImplement the LRUCache class:\n\nLRUCache(int capacity) Initialize the LRU cache with positive size capacity.\nint get(int key) Return the value of the key if the key exists, otherwise return -1.\nvoid put(int key, int value) Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key.\nThe functions get and put must each run in O(1) average time complexity.",
      "examples": [
        {
          "input": "[\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"], [[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]",
          "output": "[null, null, null, 1, null, -1, null, -1, 3, 4]",
          "explanation": "LRUCache lRUCache = new LRUCache(2);\nlRUCache.put(1, 1); // cache is {1=1}\nlRUCache.put(2, 2); // cache is {1=1, 2=2}\nlRUCache.get(1);    // return 1\nlRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}\nlRUCache.get(2);    // returns -1 (not found)\nlRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}\nlRUCache.get(1);    // return -1 (not found)\nlRUCache.get(3);    // return 3\nlRUCache.get(4);    // return 4"
        }
      ],
      "constraints": "1 <= capacity <= 3000\n0 <= key <= 10^4\n0 <= value <= 10^5\nAt most 2 * 10^5 calls will be made to get and put.",
      "solution": "from collections import OrderedDict\n\nclass LRUCache:\n\n    def __init__(self, capacity):\n        self.cache = OrderedDict()\n        self.capacity = capacity\n\n    def get(self, key):\n        if key not in self.cache:\n            return -1\n        value = self.cache[key]\n        del self.cache[key]\n        self.cache[key] = value\n        return value\n\n    def put(self, key, value):\n        if key in self.cache:\n            del self.cache[key]\n        self.cache[key] = value\n        if len(self.cache) > self.capacity:\n            self.cache.popitem(last=False)",
      "explanation": "1. 使用 OrderedDict 來保持 key 的順序。\n2. get 方法：如果 key 存在，先刪除再插入到末尾，表示最近使用，返回 value；不存在返回 -1。\n3. put 方法：如果 key 已存在，先刪除再插入到末尾；插入新 key 後，如果超過容量，移除最久未使用的 key。\n4. 這樣可以保證 get 和 put 平均 O(1) 時間複雜度。",
      "tag": "611",
      "difficult": "medium"
    }
  ]
}
