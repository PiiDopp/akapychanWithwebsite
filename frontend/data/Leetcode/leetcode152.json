{
  "ID": "leetcode152",
  "coding_practice": [
    {
      "title": "Maximum Product Subarray",
      "description": "Given an integer array nums, find a subarray that has the largest product, and return the product.\n\nThe test cases are generated so that the answer will fit in a 32-bit integer.",
      "examples": [
        {
          "input": "nums = [2,3,-2,4]",
          "output": "6",
          "explanation": "[2,3] has the largest product 6."
        },
        {
          "input": "nums = [-2,0,-1]",
          "output": "0",
          "explanation": "The result cannot be 2, because [-2,-1] is not a subarray."
        }
      ],
      "constraints": "1 <= nums.length <= 2 * 10^4\n-10 <= nums[i] <= 10\nThe product of any subarray of nums is guaranteed to fit in a 32-bit integer.",
      "solution": "class Solution:\n    def maxProduct(self, nums):\n        if not nums:\n            return 0\n\n        max_prod = min_prod = result = nums[0]\n\n        for num in nums[1:]:\n            if num < 0:\n                max_prod, min_prod = min_prod, max_prod\n\n            max_prod = max(num, max_prod * num)\n            min_prod = min(num, min_prod * num)\n\n            result = max(result, max_prod)\n\n        return result",
      "explanation": "1. 使用動態規劃，維護每個位置的當前最大乘積和最小乘積。\n2. 遇到負數時交換最大值與最小值，因為負負得正可能產生更大乘積。\n3. 每步更新全局最大乘積。\n4. 返回整個序列的最大乘積。",
      "tag": "611",
      "difficult": "medium"
    }
  ]
}
