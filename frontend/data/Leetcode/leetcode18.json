{
  "ID": "leetcode18",
  "coding_practice": [
    {
      "title": "4Sum",
      "description": "Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:\n\n0 <= a, b, c, d < n\na, b, c, and d are distinct.\nnums[a] + nums[b] + nums[c] + nums[d] == target\nYou may return the answer in any order.",
      "examples": [
        {
          "input": "nums = [1,0,-1,0,-2,2], target = 0",
          "output": "[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]"
        },
        {
          "input": "nums = [2,2,2,2,2], target = 8",
          "output": "[[2,2,2,2]]"
        }
      ],
      "constraints": "1 <= nums.length <= 200\n-10^9 <= nums[i] <= 10^9\n-10^9 <= target <= 10^9",
      "solution": "class Solution(object):\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        nums.sort()\n        n = len(nums)\n        res = []\n\n        for i in range(n - 3):\n            if i > 0 and nums[i] == nums[i - 1]:\n                continue\n            for j in range(i + 1, n - 2):\n                if j > i + 1 and nums[j] == nums[j - 1]:\n                    continue\n                left, right = j + 1, n - 1\n                while left < right:\n                    total = nums[i] + nums[j] + nums[left] + nums[right]\n                    if total == target:\n                        res.append([nums[i], nums[j], nums[left], nums[right]])\n                        while left < right and nums[left] == nums[left + 1]:\n                            left += 1\n                        while left < right and nums[right] == nums[right - 1]:\n                            right -= 1\n                        left += 1\n                        right -= 1\n                    elif total < target:\n                        left += 1\n                    else:\n                        right -= 1\n        return res",
      "explanation": "1. 將數組排序，方便使用雙指針策略。\n2. 外層使用兩層 for 迴圈固定前兩個數，跳過重複元素。\n3. 內層使用雙指針 left 和 right 尋找剩餘兩個數，使總和等於目標值。\n4. 找到符合條件的四元組後，跳過重複元素，並移動指針繼續搜索。\n5. 返回所有不重複的四元組列表。",
      "tag": "511",
      "difficult": "medium"
    }
  ]
}
