{
  "ID": "leetcode189",
  "coding_practice": [
    {
      "title": "Rotate Array",
      "description": "Given an integer array nums, rotate the array to the right by k steps, where k is non-negative.",
      "examples": [
        {
          "input": "nums = [1,2,3,4,5,6,7], k = 3",
          "output": "[5,6,7,1,2,3,4]",
          "explanation": "rotate 1 steps to the right: [7,1,2,3,4,5,6]; rotate 2 steps to the right: [6,7,1,2,3,4,5]; rotate 3 steps to the right: [5,6,7,1,2,3,4]"
        },
        {
          "input": "nums = [-1,-100,3,99], k = 2",
          "output": "[3,99,-1,-100]",
          "explanation": "rotate 1 steps to the right: [99,-1,-100,3]; rotate 2 steps to the right: [3,99,-1,-100]"
        }
      ],
      "constraints": "1 <= nums.length <= 10^5; -2^31 <= nums[i] <= 2^31 - 1; 0 <= k <= 10^5",
      "follow up": "Try to come up with as many solutions as you can. There are at least three different ways to solve this problem. \nCould you do it in-place with O(1) extra space?",
      "solution": "class Solution:\n    def rotate(self, nums, k):\n        k = k % len(nums)\n        nums[:] = nums[-k:] + nums[:-k]",
      "explanation": "1. 使用 k % len(nums) 避免 k 大於陣列長度的情況。\n2. 透過切片操作 nums[-k:] + nums[:-k]，將最後 k 個元素移到最前面，達成右旋轉效果。\n3. 使用 nums[:] 使修改作用於原陣列 (in-place)。",
      "tag": "611",
      "difficult": "medium"
    }
  ]
}
