{
  "ID": "leetcode287",
  "coding_practice": [
    {
      "title": "Find the Duplicate Number",
      "description": "Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive.\n\nThere is only one repeated number in nums, return this repeated number.\n\nYou must solve the problem without modifying the array nums and using only constant extra space.",
      "examples": [
        {
          "input": "nums = [1,3,4,2,2]",
          "output": "2"
        },
        {
          "input": "nums = [3,1,3,4,2]",
          "output": "3"
        },
        {
          "input": "nums = [3,3,3,3,3]",
          "output": "3"
        }
      ],
      "constraints": "1 <= n <= 10^5\nnums.length == n + 1\n1 <= nums[i] <= n\nAll the integers in nums appear only once except for precisely one integer which appears two or more times.",
      "follow up": "How can we prove that at least one duplicate number must exist in nums?\nCan you solve the problem in linear runtime complexity?",
      "solution": "class Solution:\n    def findDuplicate(self, nums):\n        # 使用 Floyd's Tortoise and Hare (Cycle Detection) 演算法\n        slow = fast = nums[0]\n        \n        # 第一階段: 找到相遇點\n        while True:\n            slow = nums[slow]\n            fast = nums[nums[fast]]\n            if slow == fast:\n                break\n        \n        # 第二階段: 找到入環點（重複數字）\n        slow = nums[0]\n        while slow != fast:\n            slow = nums[slow]\n            fast = nums[fast]\n        \n        return slow",
      "explanation": "1. 將 nums 視為鏈表，數值為指向下一個索引的指針。\n2. 使用快慢指針 (Floyd's Tortoise and Hare) 找到相遇點，保證存在環。\n3. 將慢指針重新指向起點，快慢指針同速移動，直到再次相遇。\n4. 相遇點即為重複的數字。",
      "tag": "520",
      "difficult": "medium"
    }
  ]
}

