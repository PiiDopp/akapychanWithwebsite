{
  "ID": "leetcode33",
  "coding_practice": [
    {
      "title": "Search in Rotated Sorted Array",
      "description": "There is an integer array nums sorted in ascending order (with distinct values).\n\nPrior to being passed to your function, nums is possibly left rotated at an unknown index k (1 <= k < nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be left rotated by 3 indices and become [4,5,6,7,0,1,2].\n\nGiven the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums.\n\nYou must write an algorithm with O(log n) runtime complexity.",
      "examples": [
        {
          "input": "nums = [4,5,6,7,0,1,2], target = 0",
          "output": "4"
        },
        {
          "input": "nums = [4,5,6,7,0,1,2], target = 3",
          "output": "-1"
        },
        {
          "input": "nums = [1], target = 0",
          "output": "-1"
        }
      ],
      "constraints": "1 <= nums.length <= 5000\n-10^4 <= nums[i] <= 10^4\nAll values of nums are unique.\nnums is an ascending array that is possibly rotated.\n-10^4 <= target <= 10^4",
      "solution": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        left, right = 0, len(nums) - 1\n\n        while left <= right:\n            mid = (left + right) // 2\n\n            if nums[mid] == target:\n                return mid\n\n            if nums[left] <= nums[mid]:  # 左半段有序\n                if nums[left] <= target < nums[mid]:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            else:  # 右半段有序\n                if nums[mid] < target <= nums[right]:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n\n        return -1",
      "explanation": "1. 初始化：\n   1.1 設定左右指標 left = 0, right = len(nums) - 1。\n2. 二分搜尋：\n   2.1 計算中間索引 mid = (left + right) // 2。\n   2.2 如果 nums[mid] == target，直接回傳 mid。\n3. 判斷有序區段：\n   3.1 如果左半段有序 (nums[left] <= nums[mid])，檢查 target 是否在左半段，否則搜尋右半段。\n   3.2 否則右半段有序，檢查 target 是否在右半段，否則搜尋左半段。\n4. 若搜尋結束仍未找到，回傳 -1。\n5. 複雜度分析：\n   5.1 時間複雜度：O(log n)\n   5.2 空間複雜度：O(1)",
      "tag": "611",
      "difficult": "medium"
    }
  ]
}
