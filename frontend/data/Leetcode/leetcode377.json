{
  "ID": "leetcode377",
  "coding_practice": [
    {
      "title": "Combination Sum IV",
      "description": "Given an array of distinct integers nums and a target integer target, return the number of possible combinations that add up to target. \n\nThe test cases are generated so that the answer can fit in a 32-bit integer.",
      "examples": [
        {
          "input": "nums = [1,2,3], target = 4",
          "output": "7",
          "explanation": "The possible combination ways are:\n(1, 1, 1, 1)\n(1, 1, 2)\n(1, 2, 1)\n(1, 3)\n(2, 1, 1)\n(2, 2)\n(3, 1)\nNote that different sequences are counted as different combinations."
        },
        {
          "input": "nums = [9], target = 3",
          "output": "0"
        }
      ],
      "constraints": "1 <= nums.length <= 200\n1 <= nums[i] <= 1000\nAll the elements of nums are unique.\n1 <= target <= 1000",
      "follow up": "What if negative numbers are allowed in the given array? How does it change the problem? What limitation we need to add to the question to allow negative numbers?",
      "solution": "class Solution:\n    def combinationSum4(self, nums, target):\n        dp = [0] * (target + 1)\n        dp[0] = 1  # base case: one way to reach 0\n        \n        for i in range(1, target + 1):\n            for num in nums:\n                if i - num >= 0:\n                    dp[i] += dp[i - num]\n        \n        return dp[target]",
      "explanation": "1. 定義 dp[i] 表示組合總和為 i 的方法數。\n2. 初始化 dp[0] = 1，表示總和為0只有一種方法，即不選任何數。\n3. 對於每個總和 i，遍歷 nums 中的數字，如果 i - num >= 0，則將 dp[i - num] 加到 dp[i] 上。\n4. 最終返回 dp[target] 即可。\n5. 時間複雜度為 O(target * len(nums))，空間複雜度為 O(target)。",
      "tag": "611",
      "difficult": "medium"
    }
  ]
}
