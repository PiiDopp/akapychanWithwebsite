{
  "ID": "leetcode449",
  "coding_practice": [
    {
      "title": "Serialize and Deserialize BST",
      "description": "Serialization is converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.\n\nDesign an algorithm to serialize and deserialize a binary search tree. There is no restriction on how your serialization/deserialization algorithm should work. You need to ensure that a binary search tree can be serialized to a string, and this string can be deserialized to the original tree structure.\n\nThe encoded string should be as compact as possible.",
      "examples": [
        {
          "input": "root = [2,1,3]",
          "output": "[2,1,3]"
        },
        {
          "input": "root = []",
          "output": "[]"
        }
      ],
      "constraints": "The number of nodes in the tree is in the range [0, 10^4].\n0 <= Node.val <= 10^4\nThe input tree is guaranteed to be a binary search tree.",
      "solution": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Codec:\n    def serialize(self, root):\n        \"\"\"Encodes a tree to a single string.\"\"\"\n        res = []\n        \n        def preorder(node):\n            if not node:\n                return\n            res.append(str(node.val))\n            preorder(node.left)\n            preorder(node.right)\n        \n        preorder(root)\n        return ','.join(res)\n    \n    def deserialize(self, data):\n        \"\"\"Decodes your encoded data to tree.\"\"\"\n        if not data:\n            return None\n        preorder = list(map(int, data.split(',')))\n        \n        def build(min_val, max_val):\n            if preorder and min_val < preorder[0] < max_val:\n                val = preorder.pop(0)\n                node = TreeNode(val)\n                node.left = build(min_val, val)\n                node.right = build(val, max_val)\n                return node\n            return None\n        \n        return build(float('-inf'), float('inf'))",
      "explanation": "1. 使用前序遍歷將 BST 序列化為字符串，每個節點值用逗號分隔。\n2. 反序列化時，根據 BST 性質（左子樹 < 根 < 右子樹）使用遞歸構建樹。\n3. 以 min_val 和 max_val 限制每個節點的合法範圍，確保構建正確的 BST。\n4. 返回重建的 BST 根節點。",
      "tag": "711",
      "difficult": "medium"
    }
  ]
}
