{
  "ID": "leetcode46",
  "coding_practice": [
    {
      "title": "Permutations",
      "description": "Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.",
      "examples": [
        {
          "input": "nums = [1,2,3]",
          "output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]"
        },
        {
          "input": "nums = [0,1]",
          "output": "[[0,1],[1,0]]"
        },
        {
          "input": "nums = [1]",
          "output": "[[1]]"
        }
      ],
      "constraints": "1 <= nums.length <= 6\n-10 <= nums[i] <= 10\nAll the integers of nums are unique.",
      "solution": "class Solution(object):\n    def permute(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        res = []\n\n        def backtrack(start):\n            if start == len(nums):\n                res.append(nums[:])\n                return\n            for i in range(start, len(nums)):\n                nums[start], nums[i] = nums[i], nums[start]\n                backtrack(start + 1)\n                nums[start], nums[i] = nums[i], nums[start]\n\n        backtrack(0)\n        return res",
      "explanation": "1. 使用回溯法從 start 位置開始生成排列。\n2. 遞迴終止條件：當 start == len(nums) 時，將當前排列加入結果 res。\n3. 對每個位置 i 從 start 到 len(nums)-1 交換 nums[start] 與 nums[i]。\n4. 遞迴調用 backtrack(start + 1) 生成下一層排列。\n5. 回溯恢復 nums[start], nums[i] 的交換，繼續嘗試其他排列。\n6. 複雜度分析：\n   6.1 時間複雜度：O(n!)\n   6.2 空間複雜度：O(n)（遞迴棧深度）",
      "tag": "611",
      "difficult": "medium"
    }
  ]
}
