{
  "ID": "leetcode466",
  "coding_practice": [
    {
      "title": "Count The Repetitions",
      "description": "We define str = [s, n] as the string str which consists of the string s concatenated n times.\n\nFor example, str == [\"abc\", 3] == \"abcabcabc\".\nWe define that string s1 can be obtained from string s2 if we can remove some characters from s2 such that it becomes s1.\n\nFor example, s1 = \"abc\" can be obtained from s2 = \"abdbec\" based on our definition by removing the bolded underlined characters.\nYou are given two strings s1 and s2 and two integers n1 and n2. You have the two strings str1 = [s1, n1] and str2 = [s2, n2].\n\nReturn the maximum integer m such that str = [str2, m] can be obtained from str1.",
      "examples": [
        {
          "input": "s1 = \"acb\", n1 = 4, s2 = \"ab\", n2 = 2",
          "output": "2"
        },
        {
          "input": "s1 = \"acb\", n1 = 1, s2 = \"acb\", n2 = 1",
          "output": "1"
        }
      ],
      "constraints": "1 <= s1.length, s2.length <= 100\ns1 and s2 consist of lowercase English letters.\n1 <= n1, n2 <= 10^6",
      "solution": "class Solution:\n    def getMaxRepetitions(self, s1, n1, s2, n2):\n        from collections import defaultdict\n        \n        if n1 == 0:\n            return 0\n        \n        s1_count = 0\n        s2_count = 0\n        index = 0\n        recall = dict()\n        \n        while s1_count < n1:\n            for ch in s1:\n                if ch == s2[index]:\n                    index += 1\n                    if index == len(s2):\n                        index = 0\n                        s2_count += 1\n            s1_count += 1\n            if index in recall:\n                s1_count_prev, s2_count_prev = recall[index]\n                pre_loop = (s1_count_prev, s2_count_prev)\n                in_loop = (s1_count - s1_count_prev, s2_count - s2_count_prev)\n                break\n            else:\n                recall[index] = (s1_count, s2_count)\n        else:\n            return s2_count // n2\n        \n        ans = pre_loop[1] + ((n1 - pre_loop[0]) // in_loop[0]) * in_loop[1]\n        rest = (n1 - pre_loop[0]) % in_loop[0]\n        s2_count_rest = 0\n        index_rest = index\n        for _ in range(rest):\n            for ch in s1:\n                if ch == s2[index_rest]:\n                    index_rest += 1\n                    if index_rest == len(s2):\n                        index_rest = 0\n                        s2_count_rest += 1\n        ans += s2_count_rest\n        return ans // n2",
      "explanation": "1. 使用循環檢測法 (Cycle Detection) 以避免直接模擬 n1 次 s1，節省時間。\n2. 記錄每個 index 對應的 (s1_count, s2_count) 到 recall，以便找到循環。\n3. 找到循環後，計算 pre_loop 部分的 s2_count，循環內的 s2_count，然後加上剩餘部分。\n4. 最後除以 n2 得到最大可重複 m。",
      "tag": "711",
      "difficult": "hard"
    }
  ]
}
