{
  "ID": "leetcode493",
  "coding_practice": [
    {
      "title": "Reverse Pairs",
      "description": "Given an integer array nums, return the number of reverse pairs in the array.\n\nA reverse pair is a pair (i, j) where:\n\n0 <= i < j < nums.length and\nnums[i] > 2 * nums[j].",
      "examples": [
        {
          "input": "nums = [1,3,2,3,1]",
          "output": "2",
          "explanation": "The reverse pairs are:\n(1, 4) --> nums[1] = 3, nums[4] = 1, 3 > 2 * 1\n(3, 4) --> nums[3] = 3, nums[4] = 1, 3 > 2 * 1"
        },
        {
          "input": "nums = [2,4,3,5,1]",
          "output": "3",
          "explanation": "The reverse pairs are:\n(1, 4) --> nums[1] = 4, nums[4] = 1, 4 > 2 * 1\n(2, 4) --> nums[2] = 3, nums[4] = 1, 3 > 2 * 1\n(3, 4) --> nums[3] = 5, nums[4] = 1, 5 > 2 * 1"
        }
      ],
      "constraints": "1 <= nums.length <= 5 * 10^4\n-2^31 <= nums[i] <= 2^31 - 1",
      "solution": "class Solution:\n    def reversePairs(self, nums):\n        def merge_sort(start, end):\n            if start >= end:\n                return 0\n            mid = (start + end) // 2\n            count = merge_sort(start, mid) + merge_sort(mid + 1, end)\n            j = mid + 1\n            for i in range(start, mid + 1):\n                while j <= end and nums[i] > 2 * nums[j]:\n                    j += 1\n                count += j - (mid + 1)\n            temp = []\n            left, right = start, mid + 1\n            while left <= mid and right <= end:\n                if nums[left] <= nums[right]:\n                    temp.append(nums[left])\n                    left += 1\n                else:\n                    temp.append(nums[right])\n                    right += 1\n            while left <= mid:\n                temp.append(nums[left])\n                left += 1\n            while right <= end:\n                temp.append(nums[right])\n                right += 1\n            nums[start:end + 1] = temp\n            return count\n        return merge_sort(0, len(nums) - 1)",
      "explanation": "1. 使用分治法 (merge sort) 將數組拆分成左右兩部分。\n2. 在合併前，對左半部分的每個元素 nums[i]，找右半部分所有滿足 nums[i] > 2 * nums[j] 的 j，累加 count。\n3. 合併兩個已排序的子數組，保持數組排序。\n4. 返回最終 reverse pairs 的總數。",
      "tag": "632",
      "difficult": "hard"
    }
  ]
}
