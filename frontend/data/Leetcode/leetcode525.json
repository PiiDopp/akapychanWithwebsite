{
  "ID": "leetcode525",
  "coding_practice": [
    {
      "title": "Contiguous Array",
      "description": "Given a binary array nums, return the maximum length of a contiguous subarray with an equal number of 0 and 1.",
      "examples": [
        {
          "input": "[0,1]",
          "output": "2",
          "explanation": "[0, 1] is the longest contiguous subarray with an equal number of 0 and 1."
        },
        {
          "input": "[0,1,0]",
          "output": "2",
          "explanation": "[0, 1] (or [1, 0]) is a longest contiguous subarray with equal number of 0 and 1."
        },
        {
          "input": "[0,1,1,1,1,1,0,0,0]",
          "output": "6",
          "explanation": "[1,1,1,0,0,0] is the longest contiguous subarray with equal number of 0 and 1."
        }
      ],
      "constraints": "1 <= nums.length <= 10^5\nnums[i] is either 0 or 1.",
      "solution": "class Solution:\n    def findMaxLength(self, nums):\n        count_map = {0: -1}\n        max_len = 0\n        count = 0\n        for i, num in enumerate(nums):\n            count += 1 if num == 1 else -1\n            if count in count_map:\n                max_len = max(max_len, i - count_map[count])\n            else:\n                count_map[count] = i\n        return max_len",
      "explanation": "1. 將 0 視為 -1，1 視為 1，計算前綴和 count。\n2. 使用字典 count_map 記錄每個 count 出現的最早索引，初始化 count_map[0] = -1。\n3. 遍歷 nums，若當前 count 已存在於 count_map，則計算子陣列長度 i - count_map[count] 並更新最大值。\n4. 若 count 不在字典中，則將當前索引加入字典。\n5. 返回最大長度 max_len。",
      "tag": "511",
      "difficult": "medium"
    }
  ]
}
