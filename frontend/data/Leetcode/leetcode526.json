{
  "ID": "leetcode526",
  "coding_practice": [
    {
      "title": "Beautiful Arrangement",
      "description": "Suppose you have n integers labeled 1 through n. A permutation of those n integers perm (1-indexed) is considered a beautiful arrangement if for every i (1 <= i <= n), either of the following is true:\n\nperm[i] is divisible by i.\ni is divisible by perm[i].\nGiven an integer n, return the number of the beautiful arrangements that you can construct.",
      "examples": [
        {
          "input": "2",
          "output": "2",
          "explanation": "The first beautiful arrangement is [1,2]:\n    - perm[1] = 1 is divisible by i = 1\n    - perm[2] = 2 is divisible by i = 2\nThe second beautiful arrangement is [2,1]:\n    - perm[1] = 2 is divisible by i = 1\n    - i = 2 is divisible by perm[2] = 1"
        },
        {
          "input": "1",
          "output": "1"
        }
      ],
      "constraints": "1 <= n <= 15",
      "solution": "class Solution:\n    def countArrangement(self, n):\n        def backtrack(pos, remaining):\n            if pos > n:\n                return 1\n            total = 0\n            for x in list(remaining):\n                if x % pos == 0 or pos % x == 0:\n                    remaining.remove(x)\n                    total += backtrack(pos + 1, remaining)\n                    remaining.add(x)\n            return total\n        \n        return backtrack(1, set(range(1, n + 1)))",
      "explanation": "1. 使用回溯算法，pos 表示當前排列位置，remaining 為剩餘可選整數集合。\n2. 遍歷 remaining 中的每個數字 x，若 x % pos == 0 或 pos % x == 0，則選擇 x 放入當前位置。\n3. 遞歸進入下一個位置，回溯時將 x 放回 remaining。\n4. 當 pos > n，表示形成一個合法排列，返回 1。\n5. 累加所有合法排列數量並返回。",
      "tag": "511",
      "difficult": "medium"
    }
  ]
}
