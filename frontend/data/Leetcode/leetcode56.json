{
  "ID": "leetcode56",
  "coding_practice": [
    {
      "title": "Merge Intervals",
      "description": "Given an array of intervals where intervals[i] = [start_i, end_i], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.",
      "examples": [
        {
          "input": "intervals = [[1,3],[2,6],[8,10],[15,18]]",
          "output": "[[1,6],[8,10],[15,18]]",
          "explanation": "Since intervals [1,3] and [2,6] overlap, merge them into [1,6]."
        },
        {
          "input": "intervals = [[1,4],[4,5]]",
          "output": "[[1,5]]",
          "explanation": "Intervals [1,4] and [4,5] are considered overlapping."
        },
        {
          "input": "intervals = [[4,7],[1,4]]",
          "output": "[[1,7]]",
          "explanation": "Intervals [1,4] and [4,7] are considered overlapping."
        }
      ],
      "constraints": "1 <= intervals.length <= 10^4\nintervals[i].length == 2\n0 <= start_i <= end_i <= 10^4",
      "solution": "class Solution(object):\n    def merge(self, intervals):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        if not intervals:\n            return []\n        \n        intervals.sort(key=lambda x: x[0])\n        merged = [intervals[0]]\n        \n        for current in intervals[1:]:\n            prev = merged[-1]\n            if current[0] <= prev[1]:\n                prev[1] = max(prev[1], current[1])\n            else:\n                merged.append(current)\n        \n        return merged",
      "explanation": "1. 若輸入為空陣列，直接返回空列表。\n2. 對區間依起點排序。\n3. 初始化 merged 列表，先加入第一個區間。\n4. 遍歷其餘區間：\n   4.1 若當前區間起點 ≤ 前一區間終點 → 合併區間（更新終點為 max(prev[1], current[1])）。\n   4.2 否則直接加入 merged。\n5. 返回 merged。\n6. 複雜度分析：\n   6.1 時間複雜度：O(n log n)\n   6.2 空間複雜度：O(n)",
      "tag": "611",
      "difficult": "medium"
    }
  ]
}
