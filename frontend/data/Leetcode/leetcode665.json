{
  "ID": "leetcode665",
  "coding_practice": [
    {
      "title": "Non-decreasing Array",
      "description": "Given an array nums with n integers, your task is to check if it could become non-decreasing by modifying at most one element.\n\nWe define an array is non-decreasing if nums[i] <= nums[i + 1] holds for every i (0-based) such that (0 <= i <= n - 2).",
      "examples": [
        {
          "input": "nums = [4,2,3]",
          "output": "true",
          "explanation": "You could modify the first 4 to 1 to get a non-decreasing array."
        },
        {
          "input": "nums = [4,2,1]",
          "output": "false",
          "explanation": "You cannot get a non-decreasing array by modifying at most one element."
        }
      ],
      "constraints": "n == nums.length\n1 <= n <= 10^4\n-10^5 <= nums[i] <= 10^5",
      "solution": "class Solution:\n    def checkPossibility(self, nums):\n        count = 0\n        for i in range(1, len(nums)):\n            if nums[i] < nums[i-1]:\n                count += 1\n                if count > 1:\n                    return False\n                if i == 1 or nums[i] >= nums[i-2]:\n                    nums[i-1] = nums[i]  # 修改前一個元素\n                else:\n                    nums[i] = nums[i-1]  # 修改當前元素\n        return True",
      "explanation": "1. 初始化計數器 count 為 0，表示修改次數。\\n2. 遍歷 nums，若 nums[i] < nums[i-1]，則需要修改一次。\\n3. 若 count > 1，返回 False。\\n4. 根據 i 與 nums[i-2] 的值決定修改前一個或當前元素，以維持非遞減性。\\n5. 遍歷完成後返回 True，表示可以通過最多一次修改使數組非遞減。",
      "tag": "511",
      "difficult": "medium"
    }
  ]
}
