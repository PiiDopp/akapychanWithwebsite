{
  "ID": "leetcode673",
  "coding_practice": [
    {
      "title": "Number of Longest Increasing Subsequence",
      "description": "Given an integer array nums, return the number of longest increasing subsequences.\n\nNotice that the sequence has to be strictly increasing.",
      "examples": [
        {
          "input": "nums = [1,3,5,4,7]",
          "output": "2",
          "explanation": "The two longest increasing subsequences are [1, 3, 4, 7] and [1, 3, 5, 7]."
        },
        {
          "input": "nums = [2,2,2,2,2]",
          "output": "5",
          "explanation": "TThe length of the longest increasing subsequence is 1, and there are 5 increasing subsequences of length 1, so output 5."
        }
      ],
      "constraints": "1 <= nums.length <= 2000\n-10^6 <= nums[i] <= 10^6\nThe answer is guaranteed to fit inside a 32-bit integer.",
      "solution": "class Solution:\n    def findNumberOfLIS(self, nums):\n        n = len(nums)\n        if n == 0:\n            return 0\n        lengths = [1] * n  # lengths[i] = length of LIS ending at i\n        counts = [1] * n   # counts[i] = number of LIS ending at i\n        \n        for i in range(n):\n            for j in range(i):\n                if nums[i] > nums[j]:\n                    if lengths[j] + 1 > lengths[i]:\n                        lengths[i] = lengths[j] + 1\n                        counts[i] = counts[j]\n                    elif lengths[j] + 1 == lengths[i]:\n                        counts[i] += counts[j]\n        \n        longest = max(lengths)\n        return sum(c for l, c in zip(lengths, counts) if l == longest)",
      "explanation": "1. 使用 lengths[i] 記錄以 nums[i] 結尾的最長遞增子序列長度。\\n2. 使用 counts[i] 記錄以 nums[i] 結尾的最長遞增子序列數量。\\n3. 遍歷 nums，對每個 i，檢查 j < i 且 nums[i] > nums[j]，更新 lengths[i] 和 counts[i]。\\n4. 找出全局最大長度 longest。\\n5. 統計所有 lengths[i] == longest 的 counts[i] 之和即為答案。",
      "tag": "511",
      "difficult": "medium"
    }
  ]
}
