{
  "ID": "leetcode706",
  "coding_practice": [
    {
      "title": "Design HashMap",
      "description": "Design a HashMap without using any built-in hash table libraries.\n\nImplement the MyHashMap class:\n\nMyHashMap() initializes the object with an empty map.\nvoid put(int key, int value) inserts a (key, value) pair into the HashMap. If the key already exists in the map, update the corresponding value.\nint get(int key) returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key.\nvoid remove(key) removes the key and its corresponding value if the map contains the mapping for the key.",
      "examples": [
        {
          "input": "[\"MyHashMap\", \"put\", \"put\", \"get\", \"get\", \"put\", \"get\", \"remove\", \"get\"]\n[[], [1, 1], [2, 2], [1], [3], [2, 1], [2], [2], [2]]",
          "output": "[null, null, null, 1, -1, null, 1, null, -1]",
          "explanation": "MyHashMap myHashMap = new MyHashMap(); \nmyHashMap.put(1, 1); // The map is now [[1,1]] \nmyHashMap.put(2, 2); // The map is now [[1,1], [2,2]] \nmyHashMap.get(1);    // return 1, The map is now [[1,1], [2,2]] \nmyHashMap.get(3);    // return -1 (i.e., not found), The map is now [[1,1], [2,2]] \nmyHashMap.put(2, 1); // The map is now [[1,1], [2,1]] (i.e., update the existing value) \nmyHashMap.get(2);    // return 1, The map is now [[1,1], [2,1]] \nmyHashMap.remove(2); // remove the mapping for 2, The map is now [[1,1]] \nmyHashMap.get(2);    // return -1 (i.e., not found), The map is now [[1,1]]"
        }
      ],
      "constraints": "0 <= key, value <= 10^6\nAt most 10^4 calls will be made to put, get, and remove.",
      "solution": "class MyHashMap:\n    def __init__(self):\n        self.size = 10000\n        self.buckets = [[] for _ in range(self.size)]\n\n    def _hash(self, key):\n        return key % self.size\n\n    def put(self, key, value):\n        h = self._hash(key)\n        for i, (k, v) in enumerate(self.buckets[h]):\n            if k == key:\n                self.buckets[h][i] = (key, value)\n                return\n        self.buckets[h].append((key, value))\n\n    def get(self, key):\n        h = self._hash(key)\n        for k, v in self.buckets[h]:\n            if k == key:\n                return v\n        return -1\n\n    def remove(self, key):\n        h = self._hash(key)\n        for i, (k, v) in enumerate(self.buckets[h]):\n            if k == key:\n                self.buckets[h].pop(i)\n                return",
      "explanation": "1. 使用列表 buckets 作為 hash table，每個 bucket 是 list 處理衝突。\\n2. _hash(key) 計算 key 對 size 取模，決定放在哪個 bucket。\\n3. put: 若 key 已存在 bucket，更新其值；否則加入新 (key, value) 元組。\\n4. get: 查找 bucket 中是否有 key，返回對應 value，否則返回 -1。\\n5. remove: 若 key 在 bucket 中，刪除該元素。\\n6. 平均時間複雜度 O(1)，最壞 O(n)，空間複雜度 O(n)。",
      "tag": "611",
      "difficult": "easy"
    }
  ]
}

