{
  "ID": "leetcode715",
  "coding_practice": [
    {
      "title": "Range Module",
      "description": "A Range Module is a module that tracks ranges of numbers. Design a data structure to track the ranges represented as half-open intervals and query about them. \n\nA half-open interval [left, right) denotes all the real numbers x where left <= x < right. \n\nImplement the RangeModule class: \nRangeModule() Initializes the object of the data structure.\nvoid addRange(int left, int right) Adds the half-open interval [left, right), tracking every real number in that interval. Adding an interval that partially overlaps with currently tracked numbers should add any numbers in the interval [left, right) that are not already tracked.\nboolean queryRange(int left, int right) Returns true if every real number in the interval [left, right) is currently being tracked, and false otherwise.\nvoid removeRange(int left, int right) Stops tracking every real number currently being tracked in the half-open interval [left, right).",
      "examples": [
        {
          "input": "RangeModule rangeModule = new RangeModule();\\nrangeModule.addRange(10, 20);\\nrangeModule.removeRange(14, 16);\\nrangeModule.queryRange(10, 14);\\nrangeModule.queryRange(13, 15);\\nrangeModule.queryRange(16, 17);",
          "output": "[null, null, null, true, false, true]",
          "explanation": "RangeModule rangeModule = new RangeModule(); \nrangeModule.addRange(10, 20);\nrangeModule.removeRange(14, 16);\nrangeModule.queryRange(10, 14); // return True,(Every number in [10, 14) is being tracked)\nrangeModule.queryRange(13, 15); // return False,(Numbers like 14, 14.03, 14.17 in [13, 15) are not being tracked)\nrangeModule.queryRange(16, 17); // return True, (The number 16 in [16, 17) is still being tracked, despite the remove operation)"
        }
      ],
      "constraints": "1 <= left < right <= 10^9\\nAt most 10^4 calls will be made to addRange, queryRange, and removeRange.",
      "solution": "import bisect\n\nclass RangeModule:\n    def __init__(self):\n        self.ranges = []\n\n    def addRange(self, left, right):\n        new_ranges = []\n        placed = False\n        for l, r in self.ranges:\n            if r < left:\n                new_ranges.append([l, r])\n            elif right < l:\n                if not placed:\n                    new_ranges.append([left, right])\n                    placed = True\n                new_ranges.append([l, r])\n            else:\n                left = min(left, l)\n                right = max(right, r)\n        if not placed:\n            new_ranges.append([left, right])\n        self.ranges = new_ranges\n\n    def queryRange(self, left, right):\n        i = bisect.bisect_right(self.ranges, [left, float('inf')])\n        if i == 0:\n            return False\n        return self.ranges[i-1][0] <= left and right <= self.ranges[i-1][1]\n\n    def removeRange(self, left, right):\n        new_ranges = []\n        for l, r in self.ranges:\n            if r <= left or l >= right:\n                new_ranges.append([l, r])\n            else:\n                if l < left:\n                    new_ranges.append([l, left])\n                if r > right:\n                    new_ranges.append([right, r])\n        self.ranges = new_ranges",
      "explanation": "1. 使用 self.ranges 存儲已追蹤區間，維持不重疊、排序的區間列表。\\n2. addRange: 遍歷已存在區間，如果有重疊，合併區間，最後更新 self.ranges。\\n3. queryRange: 使用 bisect 找到左邊界的插入點，檢查左邊區間是否完全覆蓋 [left, right)。\\n4. removeRange: 遍歷區間，對重疊區間進行切割，保留非重疊部分。",
      "tag": "1030",
      "difficult": "hard"
    }
  ]
}
