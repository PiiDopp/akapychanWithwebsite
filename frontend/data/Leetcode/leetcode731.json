{
  "ID": "leetcode731",
  "coding_practice": [
    {
      "title": "My Calendar II",
      "description": "You are implementing a program to use as your calendar. We can add a new event if adding the event will not cause a triple booking.\n\nA triple booking happens when three events have some non-empty intersection (i.e., some moment is common to all the three events.).\n\nThe event can be represented as a pair of integers startTime and endTime that represents a booking on the half-open interval [startTime, endTime), the range of real numbers x such that startTime <= x < endTime.\n\nImplement the MyCalendarTwo class:\n\nMyCalendarTwo() Initializes the calendar object.\nboolean book(int startTime, int endTime) Returns true if the event can be added to the calendar successfully without causing a triple booking. Otherwise, return false and do not add the event to the calendar.",
      "examples": [
        {
          "input": "[\"MyCalendarTwo\", \"book\", \"book\", \"book\", \"book\", \"book\", \"book\"], [[], [10, 20], [50, 60], [10, 40], [5, 15], [5, 10], [25, 55]]",
          "output": "[null, true, true, true, false, true, true]",
          "explanation": "MyCalendarTwo myCalendarTwo = new MyCalendarTwo();\nmyCalendarTwo.book(10, 20); // return True, The event can be booked.\nmyCalendarTwo.book(50, 60); // return True, The event can be booked.\nmyCalendarTwo.book(10, 40); // return True, The event can be double booked.\nmyCalendarTwo.book(5, 15);  // return False, The event cannot be booked, because it would result in a triple booking.\nmyCalendarTwo.book(5, 10); // return True, The event can be booked, as it does not use time 10 which is already double booked.\nmyCalendarTwo.book(25, 55); // return True, The event can be booked, as the time in [25, 40) will be double booked with the third event, the time [40, 50) will be single booked, and the time [50, 55) will be double booked with the second event."
        }
      ],
      "constraints": "0 <= start < end <= 10^9\nAt most 1000 calls will be made to book.",
      "solution": "class MyCalendarTwo(object):\n\n    def __init__(self):\n        self.booked = []\n        self.overlaps = []\n\n    def book(self, start, end):\n        for s, e in self.overlaps:\n            if max(s, start) < min(e, end):\n                return False\n        for s, e in self.booked:\n            if max(s, start) < min(e, end):\n                self.overlaps.append((max(s, start), min(e, end)))\n        self.booked.append((start, end))\n        return True",
      "explanation": "1. 使用 booked 列表儲存已經預訂的事件區間。\n2. 使用 overlaps 列表儲存已經重疊一次的區間。\n3. 每次 book 時，先檢查新事件是否與 overlaps 有重疊，如有重疊則會造成 triple booking，回傳 False。\n4. 若無 triple booking，遍歷 booked，找出與新事件的重疊部分，加入 overlaps。\n5. 將新事件加入 booked，回傳 True。",
      "tag": "1120",
      "difficult": "medium"
    }
  ]
}
