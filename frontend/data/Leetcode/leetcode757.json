{
  "ID": "leetcode757",
  "coding_practice": [
    {
      "title": "Set Intersection Size At Least Two",
      "description": "You are given a 2D integer array intervals where intervals[i] = [starti, endi] represents all the integers from starti to endi inclusively.\n\nA containing set is an array nums where each interval from intervals has at least two integers in nums.\n\nFor example, if intervals = [[1,3], [3,7], [8,9]], then [1,2,4,7,8,9] and [2,3,4,8,9] are containing sets.\nReturn the minimum possible size of a containing set.",
      "examples": [
        {
          "input": "intervals = [[1,3],[3,7],[8,9]]",
          "output": "5",
          "explanation": "let nums = [2, 3, 4, 8, 9].\nIt can be shown that there cannot be any containing array of size 4."
        },
        {
          "input": "intervals = [[1,3],[1,4],[2,5],[3,5]]",
          "output": "3",
          "explanation": "let nums = [2, 3, 4].\nIt can be shown that there cannot be any containing array of size 2."
        },
        {
          "input": "intervals = [[1,2],[2,3],[2,4],[4,5]]",
          "output": "5",
          "explanation": "let nums = [1, 2, 3, 4, 5].\nIt can be shown that there cannot be any containing array of size 4."
        }
      ],
      "constraints": "1 <= intervals.length <= 3000\nintervals[i].length == 2\n0 <= starti < endi <= 10^8",
      "solution": "class Solution:\n    def intersectionSizeTwo(self, intervals):\n        intervals.sort(key=lambda x: (x[1], -x[0]))\n        res = []\n        last, second_last = -1, -1\n        for start, end in intervals:\n            count = 0\n            if start <= second_last <= end:\n                count += 1\n            if start <= last <= end:\n                count += 1\n            if count >= 2:\n                continue\n            elif count == 1:\n                res.append(end)\n                second_last, last = last, end\n            else:\n                res.extend([end-1, end])\n                second_last, last = end-1, end\n        return len(res)",
      "explanation": "1. 將 intervals 依照右端點升序排列，若右端點相同則左端點降序排列。\n2. 使用 greedy，維護已選的兩個最大值 last 和 second_last。\n3. 遍歷每個區間，計算 last 和 second_last 落在當前區間內的數量 count。\n4. 若 count >= 2，該區間已滿足條件，繼續。\n5. 若 count == 1，只需選擇 end 作為新的元素。\n6. 若 count == 0，選擇 end-1 和 end 作為新的元素。\n7. 最後返回 res 的長度即最小 containing set 的大小。",
      "tag": "611",
      "difficult": "hard"
    }
  ]
}
