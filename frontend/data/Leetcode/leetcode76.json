{
  "ID": "leetcode76",
  "coding_practice": [
    {
      "title": "Minimum Window Substring",
      "description": "Given two strings s and t of lengths m and n respectively, return the minimum window substring of s such that every character in t (including duplicates) is included in the window. If there is no such substring, return the empty string \"\".\n\nThe testcases will be generated such that the answer is unique.",
      "examples": [
        {
          "input": "s = \"ADOBECODEBANC\", t = \"ABC\"",
          "output": "\"BANC\"",
          "explanation": "The minimum window substring \"BANC\" includes 'A', 'B', and 'C' from string t."
        },
        {
          "input": "s = \"a\", t = \"a\"",
          "output": "\"a\"",
          "explanation": "The entire string s is the minimum window."
        },
        {
          "input": "s = \"a\", t = \"aa\"",
          "output": "\"\"",
          "explanation": "Both 'a's from t must be included in the window. Since the largest window of s only has one 'a', return empty string."
        }
      ],
      "constraints": "m == s.length\nn == t.length\n1 <= m, n <= 10^5\ns and t consist of uppercase and lowercase English letters",
      "follow up": "Could you find an algorithm that runs in O(m + n) time?",
      "solution": "class Solution(object):\n    def minWindow(self, s, t):\n        from collections import Counter\n        if not s or not t:\n            return \"\"\n        dict_t = Counter(t)\n        required = len(dict_t)\n        l, r = 0, 0\n        formed = 0\n        window_counts = {}\n        ans = float(\"inf\"), None, None\n        while r < len(s):\n            character = s[r]\n            window_counts[character] = window_counts.get(character, 0) + 1\n            if character in dict_t and window_counts[character] == dict_t[character]:\n                formed += 1\n            while l <= r and formed == required:\n                character = s[l]\n                if r - l + 1 < ans[0]:\n                    ans = (r - l + 1, l, r)\n                window_counts[character] -= 1\n                if character in dict_t and window_counts[character] < dict_t[character]:\n                    formed -= 1\n                l += 1\n            r += 1\n        return \"\" if ans[0] == float(\"inf\") else s[ans[1]:ans[2]+1]",
      "explanation": "1. 使用 Counter 計算 t 中每個字符的頻率。\n2. 初始化滑動窗口左右指針 l, r，形成字符計數 formed，窗口計數 window_counts 以及答案 ans。\n3. 移動右指針 r 擴展窗口，更新窗口中字符的計數。\n4. 當窗口中包含所有 t 的字符時，嘗試收縮左指針 l 以縮小窗口，並更新答案。\n5. 最後返回最短符合條件的子字串，若不存在則返回空字符串。",
      "tag": "721",
      "difficult": "hard"
    }
  ]
}
