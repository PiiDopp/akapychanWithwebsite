{
  "ID": "leetcode798",
  "coding_practice": [
    {
      "title": "Smallest Rotation with Highest Score",
      "description": "You are given an array nums. You can rotate it by a non-negative integer k so that the array becomes [nums[k], nums[k + 1], ... nums[nums.length - 1], nums[0], nums[1], ..., nums[k-1]]. Afterward, any entries that are less than or equal to their index are worth one point.\n\nFor example, if we have nums = [2,4,1,3,0], and we rotate by k = 2, it becomes [1,3,0,2,4]. This is worth 3 points because 1 > 0 [no points], 3 > 1 [no points], 0 <= 2 [one point], 2 <= 3 [one point], 4 <= 4 [one point].\nReturn the rotation index k that corresponds to the highest score we can achieve if we rotated nums by it. If there are multiple answers, return the smallest such index k.",
      "examples": [
        {
          "input": "nums = [2,3,1,4,0]",
          "output": "3",
          "explanation": "Scores for each k are listed below:\nk = 0,  nums = [2,3,1,4,0],    score 2\nk = 1,  nums = [3,1,4,0,2],    score 3\nk = 2,  nums = [1,4,0,2,3],    score 3\nk = 3,  nums = [4,0,2,3,1],    score 4\nk = 4,  nums = [0,2,3,1,4],    score 3\nSo we should choose k = 3, which has the highest score."
        },
        {
          "input": "nums = [1,3,0,2,4]",
          "output": "0",
          "explanation": "nums will always have 3 points no matter how it shifts.\nSo we will choose the smallest k, which is 0."
        }
      ],
      "constraints": "1 <= nums.length <= 10^5\n0 <= nums[i] < nums.length",
      "solution": "class Solution(object):\n    def bestRotation(self, A):\n        n = len(A)\n        change = [0] * n\n\n        for i, a in enumerate(A):\n            lose_start = (i - a + 1 + n) % n\n            lose_end = (i + 1) % n\n            change[lose_start] -= 1\n            change[lose_end] += 1\n            if lose_start > lose_end:\n                change[0] -= 1\n\n        max_score = -n\n        score = 0\n        best_k = 0\n\n        for k in xrange(n):\n            score += change[k]\n            if score > max_score:\n                max_score = score\n                best_k = k\n        return best_k",
      "explanation": "1. 假設初始旋轉 k=0，每個元素都得分，總分 n。\n2. 計算每個元素 A[i] 的失分區間：如果旋轉 k 落在 [i - A[i] + 1, i]，該元素失分。\n3. 使用差分陣列 change 記錄每個 k 的得分變化。\n4. 遍歷前綴和計算每個 k 的總分，找到分數最高的 k。\n5. 若有多個 k 分數相同，選擇最小的 k。",
      "tag": "1030",
      "difficult": "hard"
    }
  ]
}
