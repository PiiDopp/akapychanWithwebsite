{
  "ID": "leetcode818",
  "coding_practice": [
    {
      "title": "Race Car",
      "description": "Your car starts at position 0 and speed +1 on an infinite number line. Your car can go into negative positions. Your car drives automatically according to a sequence of instructions 'A' (accelerate) and 'R' (reverse):\n\nWhen you get an instruction 'A', your car does the following:\nposition += speed\nspeed *= 2\nWhen you get an instruction 'R', your car does the following:\nIf your speed is positive then speed = -1\notherwise speed = 1\nYour position stays the same.\nFor example, after commands \"AAR\", your car goes to positions 0 --> 1 --> 3 --> 3, and your speed goes 1 --> 2 --> 4 --> -1.\n\nGiven a target position target, return the length of the shortest sequence of instructions to get there.",
      "examples": [
        {
          "input": "target = 3",
          "output": "2",
          "explanation": "The shortest instruction sequence is \"AA\".\nYour position goes from 0 --> 1 --> 3."
        },
        {
          "input": "target = 6",
          "output": "5",
          "explanation": "The shortest instruction sequence is \"AAARA\".\nYour position goes from 0 --> 1 --> 3 --> 7 --> 7 --> 6."
        }
      ],
      "constraints": "1 <= target <= 10^4",
      "solution": "class Solution(object):\n    def racecar(self, target):\n        \"\"\"\n        :type target: int\n        :rtype: int\n        \"\"\"\n        from collections import deque\n        \n        visited = set()\n        queue = deque([(0, 1, 0)])  # (position, speed, moves)\n        \n        while queue:\n            pos, speed, moves = queue.popleft()\n            if pos == target:\n                return moves\n            # accelerate\n            next_pos, next_speed = pos + speed, speed * 2\n            if (next_pos, next_speed) not in visited and 0 <= next_pos <= 2 * target:\n                visited.add((next_pos, next_speed))\n                queue.append((next_pos, next_speed, moves + 1))\n            # reverse\n            rev_speed = -1 if speed > 0 else 1\n            if (pos, rev_speed) not in visited:\n                visited.add((pos, rev_speed))\n                queue.append((pos, rev_speed, moves + 1))",
      "explanation": "1. 使用 BFS 模擬所有可能的操作狀態，隊列中保存 (position, speed, moves)。\n2. 當前節點若位置等於 target，返回 moves。\n3. 對每個節點先加速(A)，計算新的位置與速度，加入隊列。\n4. 再嘗試反轉(R)，速度變為 -1 或 1，加入隊列。\n5. 使用 visited 集合避免重複狀態。",
      "tag": "611",
      "difficult": "hard"
    }
  ]
}
