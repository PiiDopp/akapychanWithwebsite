{
  "ID": "leetcode873",
  "coding_practice": [
    {
      "title": "Length of Longest Fibonacci Subsequence",
      "description": "A sequence x1, x2, ..., xn is Fibonacci-like if:\n\nn >= 3\nxi + xi+1 == xi+2 for all i + 2 <= n\n\nGiven a strictly increasing array arr of positive integers forming a sequence, return the length of the longest Fibonacci-like subsequence of arr. If one does not exist, return 0.\n\nA subsequence is derived from another sequence arr by deleting any number of elements (including none) from arr, without changing the order of the remaining elements. For example, [3, 5, 8] is a subsequence of [3, 4, 5, 6, 7, 8].",
      "examples": [
        {
          "input": "arr = [1,2,3,4,5,6,7,8]",
          "output": "5",
          "explanation": "The longest subsequence that is fibonacci-like: [1,2,3,5,8]."
        },
        {
          "input": "arr = [1,3,7,11,12,14,18]",
          "output": "3",
          "explanation": "The longest subsequence that is fibonacci-like: [1,11,12], [3,11,14] or [7,11,18]."
        }
      ],
      "constraints": "3 <= arr.length <= 1000\n1 <= arr[i] < arr[i + 1] <= 10^9",
      "solution": "class Solution(object):\n    def lenLongestFibSubseq(self, A):\n        s = set(A)\n        n = len(A)\n        longest = {}\n        ans = 0\n        \n        for i in range(n):\n            for j in range(i):\n                x, y = A[j], A[i]\n                if x + y in s:\n                    longest[y, x + y] = longest.get((x, y), 2) + 1\n                    ans = max(ans, longest[y, x + y])\n        return ans",
      "explanation": "1. 將數組 A 轉成集合 s，方便快速查找。\n2. 使用字典 longest 紀錄以某對數字結尾的 Fibonacci-like 子序列長度。\n3. 遍歷所有數對 (A[j], A[i])，若 A[j] + A[i] 在集合中，則更新 longest[(A[i], A[j]+A[i])] 的長度。\n4. 過程中更新最大長度 ans。\n5. 返回 ans。",
      "tag": "611",
      "difficult": "medium"
    }
  ]
}
